import { type ReadonlyEnumValues } from '../enum_values';
import type ParserOptions from '../parser_options';
/**
 * Offers a way to flatten a nested JSON structure.
 * This is used to mimic inheritance and composition in Tiled.
 */
export declare class Flattener {
    private readonly tiledClassToMembersMap;
    readonly enumNameToValuesMap: ReadonlyMap<string, ReadonlyEnumValues>;
    private readonly parserOptions?;
    /**
     * Tracks the flattened properties of each class, so that we don't have to recompute them
     * when we encounter the same class again.
     */
    private readonly memoiser;
    constructor(tiledClassToMembersMap: ReadonlyMap<string, any>, enumNameToValuesMap: ReadonlyMap<string, ReadonlyEnumValues>, parserOptions?: ParserOptions | undefined);
    /**
     * Flattens a list of members by combining them into one object, containing one key mapped to another
     * object of key-value pairs.
     *
     * The flattened properties will be memoised, so that if the same class is encountered again, the
     * flattened properties will be returned instead of being recomputed.
     *
     * The structure of the returned object is as follows:
     *
     * ```json
     * {
     *     <CLASS_NAME>: {
     *         <PROPERTY_NAME>: <PROPERTY_VALUE>,
     *         ...
     *     }
     * }
     * ```
     * It is guaranteed that there will only be one key in the object.
     *
     *
     * @param members The members to be flattened.
     * @param className The name of the class that the members belong to.
     * @param members The members of the class.
     */
    flattenMembers(className: string, members: any[]): any;
    /**
    * Flattens a *single* member of a propertyType.
    * A member consists of name, type and value, and optionally a propertyType.
    * The value can be a primitive or an object.
    *
    * This is used when the structure looks like this:
    * ```json
    * {
    *    name: <NAME>,
    *    type: <TYPE>,
    *    value: <OBJECT or PRIMITIVE>
    * }
    * ```
    *
    * The function will take out the `value` key and flatten it if it is an object.
    *
    * ```json
    * {
    *   flattened(<OBJECT>)
    * }
    * ```
    *
    * However, if the object's name has the `@composite:` prefix, then the object will not be flattened.
    * Instead, it will be a nested object under the `value` key, with its own values flattened. The key
    * will be the name of the object with the `@composite:` prefix removed.
    *
    * ```json
    * {
    *     <NAME>: flattened(<OBJECT>)
    * }
    * ```
    *
    * If the `value` is a primitive, the name of the member will be the key and the value will be its value.
    *
    * ```json
    * {
    *     <NAME>: <PRIMITIVE>
    * }
    *
    * @param member Any literal member under the `members` key of a propertyType to be flattened.
    * @param memoiser Mapping of the name of the class to its flattened properties.
    */
    flattenMemberProperty(member: any): any;
    /**
     * Returns the memoised flattened properties for all the classes,
     * indexed by the class name as given in Tiled.
     */
    get memoisedFlattenedProperties(): ReadonlyMap<string, any>;
    /**
     * Flattens a `value` key of a member recursively.
     *
     * This function is used if the structure looks like this:
     * ```json
     * {
     *     <PROPERTY_NAME>: <PROPERTY_VALUE>,
     *     <PROPERTY_NAME>: {
     *         <PROPERTY_NAME>: <PROPERTY_VALUE>,
     *         ...
     *     },
     *     ...
     * }
     * ```
     *
     * The function will recursively flatten the `value` key of the member.
     *
     * ```json
     * {
     *    <PROPERTY_NAME>: <PROPERTY_VALUE>,
     *    <PROPERTY_NAME>: <PROPERTY_VALUE>,
     *    ...
     * }
     * ```
     *
     * @param propertyValue The `value` key of the member. This is an object
     *  of key-value pairs, where the key is a string representing the name of the property,
     *  and the value is the value of the property, which could be a primitive, or another
     *  of the same object.
     * @param currentIteration The current iteration of the recursive function.
     */
    private flattenValue;
    /**
     * Checks if the member should be flattened, based on its name and the parser options.
     *
     * We should nest if either the class is declared with the `@composite:` prefix,
     * or the parser is set to default to composite classes and the class is not declared
     * with the `@inherit:` prefix.
     *
     * @param member The member to check.
     */
    private checkIfShouldFlatten;
}
